# 2025년 2월 11일
---
## 사실

### ELK kibana
- 키바나 기능
  - 데이터 분석, 시각화
  - 엘라스틱 관리
  - 엘라스틱 중앙 허브
    
- 시각화 기능
  - 디스커버
  - 시각화
  - 대시보드
  - 캔버스
  - 맵스

- 데이터뷰(ES8 이전에서는 인덱스 패턴)
  - 엘라스틱서치 인덱스에서 데이터소스를 가져오는 것을 말한다
    - 인덱스 매핑 정보 등을 키바나에 사용하기 적합하게 미리 캐싱해둔 것으로 여러 개의 인덱스에 대한 메타 데이터를 병합해 저장해뒀다가 검색이나 시각화 생성 시 활용한다.
  - 키바나에서 시각화를 하기 위해서는 꼭 엘라스틱 서치 인덱스에 연결되어야만 한다.
  - 데이터뷰를 거치는 이유 : 날짜별, 연도별로 만든 복수의 인덱스에 대한 매핑을 사전에 병합해두어 쿼리 생성이나 시각화에 활용 할 수 있기 때문.
  - 데이터는 만들어진지 얼마나 되었느냐 혹은 얼마나 자주 쓰이는 데이터들을 담고 있느냐에 따라 기준이 나뉜다.
  ![image](https://github.com/user-attachments/assets/715b935f-5150-4801-977b-e801f4ddb4ec)

이 데이터들을 주로 날짜 기준으로 인덱스화 하여 관리합니다.
dataview를 만들지 않으면 query dsl을 통한 상세 검색이 불가능합니다.

## 발견

## 배운점(복습)
- Pirmary Shard
  - 많은 데이터를 단일 노드에 저장하는것은 비효율적이므로 데이터를 여러 샤드로 나누어 각 노드에 분산저장하고 검색 쿼리 속도와 클러스터 성능 향상에 도움.
- Replica Shard
  - 특정 노드가 다운되었을시 안정성을 보장하기위한 복제 shard. primary shard가 사라지면 replica가 primary로 승격한다. 또 검색 요청을 primary 뿐 아니라 replica에도 수행 가능하다.

- refresh : 데이터를 색인 후 세그먼트라는 파일시스템에 커밋. 디스크가 아닌 메모리에 저장하는것으로 영구적이진 않다. 검색 불가능한 데이터를 검색 가능하게 함.
  - 실시간 검색을 위해서 사용되며 메모리를 사용하기때문에 많이 쓰면 성능저하 발생.
- flush : 세그먼트의 안정성을 보장하기위하여 세그먼트를 영구적으로 커밋.
  - translog를 정리하며 메모리를 최적화하지만 파일을 저장하기때문에 디스크 I/O에 부담이 된다.
  - translog : flush 전까지 데이터 안정성을 보장하기위해 임시로 저장해놓는 로그파일.

- 계층구조 : 필드 하위에 다른 필드가 들어가는 계층 구조의 데이터를 담는 타입
  - object : 기본타입
    - 필드 하위에 다른필드를 포함하는 객체 데이터를 담는 josn과 같은 형태다.
    예) put test/_doc/1{   "ob" : {  "1":"1" , "2":"2" }  } 이런 문서가 색인된다하면 "ob.1":"1" 이런식으로 평탄화된 키-값 쌍으로 색인.

      object는 배열을 평탄화시켜 같은 객체로 취급해 처리하기에 검색에 문제가 생긴다. 그래서 nested가 등장하였다.

  - nested : 배열 내 각 객체를 독립적으로 취급. (사전에 인덱스를 먼저 매핑후 nested 타입으로 정해줘야함.)
    - query - nested - path : "nested타입 필드이름"이라는 전용쿼리를 이용해 검색해야함.
    각각의 객체를 별도의 루씬 문서로 분리해 저장하기 때문에 원소가 100개라면 부모문서까지 101개를 만듬.
    그래서 성능에 문제가 생길 수 있기에 인덱스 설정으로 제한이 있다.
    - index.mapping.nested_fileds.limit
      - 인덱스 nested 갯수 리밋  (기본값 50)
    - index.mapping.nested_objects.limit
      - 문서 nested 갯수 리밋 (기본값 10000)
 
  
## 선언


### kibana에 대하여 숙지한다.

s
